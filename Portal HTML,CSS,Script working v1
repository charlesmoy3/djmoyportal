<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DJ Moy ‚Äì Mixing & Mastering Portal (Dual Mode)</title>
   <style>
      :root {
  --bg-dark: #0a0118;
  --bg-gradient-start: #1a0b2e;
  --bg-gradient-end: #0f0520;
  --card-glass: rgba(20, 15, 40, 0.7);
  --card-border: rgba(147, 112, 219, 0.3);
  --text: #ffffff;
  --muted: rgba(255, 255, 255, 0.7);
  --muted2: rgba(255, 255, 255, 0.5);
  --accent: #a855f7;
  --accent2: #06b6d4;
  --warn: #ef4444;
  --glow-purple: rgba(168, 85, 247, 0.4);
  --glow-blue: rgba(59, 130, 246, 0.3);
  --shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
  --radius: 18px;
  --line: rgba(255, 255, 255, 0.1);
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family:
    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu,
    Cantarell, sans-serif;
  color: var(--text);
  min-height: 100%;
  position: relative;
  overflow-x: hidden;
  background-color: #000;
  background-image: url(https://clinquant-melomakarona-92e574.netlify.app/bg.png);
  background-repeat: no-repeat;
  background-size: cover;
  background-attachment: fixed;
  width: 100%;
}

/* Animated starry background */
body::before {
  content: "";
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background:
    radial-gradient(2px 2px at 20% 30%, white, transparent),
    radial-gradient(2px 2px at 60% 70%, white, transparent),
    radial-gradient(1px 1px at 50% 50%, white, transparent),
    radial-gradient(1px 1px at 80% 10%, white, transparent),
    radial-gradient(2px 2px at 90% 60%, white, transparent),
    radial-gradient(1px 1px at 33% 85%, white, transparent),
    radial-gradient(2px 2px at 75% 25%, white, transparent),
    radial-gradient(1px 1px at 10% 80%, white, transparent);
  background-size:
    200% 200%,
    300% 300%,
    250% 250%,
    280% 280%,
    220% 220%,
    260% 260%,
    240% 240%,
    290% 290%;
  background-position: 50% 50%;
  animation: twinkle 3s ease-in-out infinite alternate;
  pointer-events: none;
  z-index: 0;
  opacity: 0.6;
}

@keyframes twinkle {
  0%,
  100% {
    opacity: 0.5;
  }
  50% {
    opacity: 0.8;
  }
}

/* Gradient overlays */
body::after {
  content: "";
  position: fixed;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background:
    radial-gradient(ellipse at 20% 30%, var(--glow-purple), transparent 50%),
    radial-gradient(ellipse at 80% 70%, var(--glow-blue), transparent 50%);
  pointer-events: none;
  z-index: 0;
  animation: gradientShift 15s ease-in-out infinite;
}

@keyframes gradientShift {
  0%,
  100% {
    transform: translate(0, 0) rotate(0deg);
  }
  50% {
    transform: translate(10%, 10%) rotate(5deg);
  }
}

/* Main container with phone frame */

.mainContainer {
  position: relative;
  z-index: 1;
  max-width: 100%;
  margin: 0 auto;
  padding: 20px 20px;          /* you can tweak this later */
  min-height: auto;            /* ‚¨ÖÔ∏è was 100vh ‚Äì this is the problem line */
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start; /* start at the top, not centered/bottom */
}

/* Logo/Brand */
.brand {
  text-align: center;
  margin: 0 0 60px;
  font-size: 64px;
  font-weight: 700;
  color: #ffffff;
  letter-spacing: 0.5px;
  font-style: italic;
  text-shadow: 0 0 30px rgba(168, 85, 247, 0.6);
}

/* Phone mockup frame */
.phoneFrame {
  display: none;
  background: linear-gradient(
    135deg,
    rgba(168, 85, 247, 0.1),
    rgba(59, 130, 246, 0.1)
  );
  border-radius: 36px;
  padding: 12px;
  box-shadow:
    0 0 60px rgba(168, 85, 247, 0.4),
    0 0 100px rgba(236, 72, 153, 0.2),
    inset 0 0 30px rgba(255, 255, 255, 0.05);
  border: 2px solid transparent;
  background-image:
    linear-gradient(135deg, rgba(168, 85, 247, 0.1), rgba(59, 130, 246, 0.1)),
    linear-gradient(
      135deg,
      rgba(168, 85, 247, 0.6),
      rgba(236, 72, 153, 0.4),
      rgba(59, 130, 246, 0.6)
    );
  background-origin: border-box;
  background-clip: padding-box, border-box;
  backdrop-filter: blur(10px);
  margin-bottom: 20px;
}

.phoneInner {
  display: none;
  background: var(--card-glass);
  border-radius: 28px;
  padding: 16px;
  min-height: 500px;
  backdrop-filter: blur(20px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  display: flex;
  flex-direction: column;
}

/* ========== ENTRY MODE ========== */
.entryWrap {
  width: 100%;
  max-width: 900px;
  margin: 0 auto 60px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}


.entryKicker {
  text-align: center;
  font-size: 11px;
  letter-spacing: 0.15em;
  text-transform: uppercase;
  color: var(--muted2);
  margin-bottom: 8px;
  font-weight: 600;
}

.entryTitle {
  font-size: 50px;
  line-height: 1.2;
  margin: 0 0 24px;
  font-weight: 600;
  text-align: center;
  background: linear-gradient(135deg, #df4af5, #fff, #4b31db);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-shadow: 0 0 40px rgba(59, 130, 246, 0.3);
  text-transform: uppercase;
}

.entryCard {
  background: rgba(20, 15, 40, 0.52);
  /*! backdrop-filter: blur(20px); */
  border: 3px solid rgba(168, 85, 247, 0.79);
  border-radius: 24px;
  padding: 40px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  margin: 16px 0;
  transition: all 0.3s ease;
  max-width: 900px;
  width: 100%;
}

.entryCard:hover {
  box-shadow:
    0 20px 40px rgba(0, 0, 0, 0.5),
    0 0 30px rgba(168, 85, 247, 0.3);
}

.entryCardHeader {
  margin-bottom: 16px;
}

.entryCardHeaderTitle {
  font-size: 20px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: rgba(255, 255, 255, 0.9);
  margin-bottom: 16px;
  text-align: center;
}

.entryCardHeaderText {
  font-size: 18px;
  color: rgba(255, 255, 255, 0.8);
  line-height: 1.6;
  text-align: center;
  max-width: 700px;
  margin: 0 auto;
}

.entryBtnGroup {
  display: flex;
  flex-direction: row;
  gap: 20px;
  margin-top: 40px;
  justify-content: center;
  flex-wrap: wrap;
}

.entryBtn {
  min-width: 280px;
  padding: 20px 40px;
  border-radius: 16px;
  font-size: 18px;
  font-weight: 700;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  background: transparent;
  border-color: rgba(168, 85, 247, 0.8);
  color: #fff;
  box-shadow: 0 0 30px rgba(168, 85, 247, 0.45), 0 0 60px rgba(168, 85, 247, 0.2), inset 0 0 30px rgba(255, 255, 255, 0.05);
}

.entryBtn:hover,
.entryBtnPrimary:hover {
  border-color: rgba(168, 85, 247, 0.8);
  box-shadow:
    0 0 30px rgba(168, 85, 247, 0.6),
    0 0 60px rgba(168, 85, 247, 0.3),
    inset 0 0 30px rgba(255, 255, 255, 0.05);
}

.entryBtnPrimary {
  border: 2px solid rgba(168, 85, 247, 0.6);
  color: #ffffff;

}
.entryBtnLabelMain {
  display: block;
  font-size: 20px;
  font-weight: 700;
  margin-bottom: 8px;
}

.entryBtnLabelSub {
  display: block;
  margin-top: 6px;
  font-size: 15px;
  font-weight: 400;
  opacity: 0.9;
  line-height: 1.4;
}

.entryBtn:not(.entryBtnPrimary) .entryBtnLabelSub {
  opacity: 0.7;
}

/* ========== GUIDED & MANUAL COMMON ========== */
.wrap,
.manualWrap {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  padding: 40px 20px 120px;
  display: flex;
  flex-direction: column;
}

.modeBackLink {
  display: inline-block;
  color: var(--muted);
  text-decoration: none;
  font-size: 14px;
  margin-bottom: 16px;
  padding: 8px 0;
  transition: color 0.3s ease;
}

.modeBackLink:hover {
  color: var(--text);
  cursor: pointer;
}

.manualHeader {
  text-align: center;
  margin-bottom: 20px;
}

.kicker {
  text-align: left;
  font-size: 14px;
  color: rgba(255, 255, 255, 0.6);
  margin-bottom: 8px;
  letter-spacing: 0.05em;
}

h1 {
  margin: 0 0 16px 0;
  font-size: 32px;
  line-height: 1.2;
  text-align: left;
  font-weight: 700;
  color: #ffffff;
}

.sub {
  margin: 0 0 20px;
  color: rgba(255, 255, 255, 0.7);
  font-size: 16px;
  line-height: 1.5;
  text-align: left;
}

/* ========== PROGRESS BAR ========== */
.stepsBar {
  display: flex;
  gap: 8px;
  margin: 5px 0 24px;
}

.stepDot {
  height: 6px;
  flex: 1;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.2);
  transition: all 0.3s ease;
}

.stepDot.on {
  background: linear-gradient(90deg, #a01cc0, #ec4899);
  box-shadow: 0 0 12px rgba(168, 85, 247, 0.6);
}

.stepLabel {
  color: rgba(255, 255, 255, 0.7);
  font-size: 16px;
  margin-bottom: 8px;
  text-align: left;
}

/* ========== CARDS ========== */
.card {
  background: rgba(20, 15, 40, 0.52);
  /*! backdrop-filter: blur(20px); */
  border: 3px solid rgba(168, 85, 247, 0.79);
  border-radius: 24px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  padding: 32px;
  margin: 0;
  transition: all 0.3s ease;
}

.card:hover {
  border-color: rgba(168, 85, 247, 0.5);
}

.card.step {
  animation: fadeIn 0.5s ease;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.cardTitle {
  display: block;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
  margin-bottom: 24px;
}

.cardTitle h2 {
  font-size: 24px;
  margin: 0;
  font-weight: 600;
  flex: 1;
  color: #ffffff;
  text-transform: uppercase;
  letter-spacing: 0.02em;
}

.hint {
  color: rgba(255, 255, 255, 0.6);
  font-size: 18px;
  line-height: 1.3;
  text-align: left;
  /*! white-space: nowrap; */
  flex-shrink: 0;
  /*! display: none; */
}

/* ========== PILL GRID ========== */
.pillGrid {
  display: flex;
  flex-direction: column;
  gap: 16px;
  margin-top: 16px;
}

.pillCard {
  /*! background: rgba(30, 20, 60, 0.5); */
  /*! backdrop-filter: blur(10px); */
  border: 2px solid rgba(168, 85, 247, 0.4);
  border-radius: 20px;
  padding: 24px;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  min-height: 90px;
  user-select: none;
  position: relative;
  overflow: hidden;
}

.pillCard::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

.pillCard:hover {
  transform: translateY(-2px);
  border-color: rgba(168, 85, 247, 0.7);
  box-shadow: 0 10px 30px rgba(168, 85, 247, 0.3);
}

.pillCard:active {
  transform: scale(0.995);
}

.pillCard.selected {
  /*! background: rgba(168, 85, 247, 0.15); */
  /*! border-color: rgba(168, 85, 247, 0.8); */
  box-shadow: 0 0 30px rgba(168, 85, 247, 0.5);
}

.pillCard.selected::before {
  opacity: 0.1;
}

.pillCard > div {
  flex: 1;
  position: relative;
  z-index: 1;
  display: flex;
  align-items: center;
  gap: 16px;
}

.pillCard .label::before {
  font-size: 24px;
  margin-right: 12px;
}

.pillCard .label {
  font-size: 18px;
  font-weight: 700;
  color: #ffffff;
  line-height: 1.3;
  display: block;
}

.pillCard .meta {
  display: block;
  margin-top: 8px;
  font-size: 15px;
  font-weight: 400;
  color: rgba(255, 255, 255, 0.7);
  line-height: 1.4;
}

.autoNote {
  display: block;
  margin-top: 6px;
  font-size: 10px;
  font-weight: 600;
  color: rgba(144, 224, 255, 0.9);
}

.dot {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  border: 2px solid rgba(255, 255, 255, 0.4);
  background: transparent;
  flex-shrink: 0;
  transition: all 0.3s ease;
  position: relative;
  z-index: 1;
}

.pillCard.selected .dot {
  background: #ffff;
  border-color: transparent;
  box-shadow: 0 0 10px #402279;
}

/* ========== INFO/NOTE BOXES ========== */
.miniNote {
  margin-top: 16px;
  padding: 16px 20px;
  border-radius: 16px;
  border: 1px solid rgba(59, 130, 246, 0.3);
  background: rgba(59, 130, 246, 0.1);
  color: rgba(255, 255, 255, 0.8);
  font-size: 14px;
  line-height: 1.6;
}

.miniNote strong {
  color: var(--text);
  font-weight: 600;
}

.miniNote.warn {
  border-color: rgba(239, 68, 68, 0.3);
  background: rgba(239, 68, 68, 0.1);
  color: rgba(255, 200, 200, 0.9);
}

.recList {
  margin: 10px 0 0 0;
  padding-left: 18px;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.5;
}

.recList li {
  margin: 5px 0;
}

/* ========== FORM FIELDS ========== */
.fieldGroup {
  margin-top: 14px;
}

.fieldLabel {
  font-size: 14px;
  font-weight: 600;
  color: rgba(255, 255, 255, 0.8);
  margin-bottom: 10px;
  display: block;
}

.textInput,
.textArea {
  width: 100%;
  padding: 14px 16px;
  background: rgba(30, 20, 60, 0.4);
  border: 1px solid rgba(168, 85, 247, 0.3);
  border-radius: 12px;
  color: var(--text);
  font-size: 15px;
  transition: all 0.3s ease;
  backdrop-filter: blur(10px);
  font-family: inherit;
}

.textInput:focus,
.textArea:focus {
  outline: none;
  border-color: var(--accent);
  background: rgba(255, 255, 255, 0.08);
  box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.1);
}

.textInput::placeholder,
.textArea::placeholder {
  color: var(--muted2);
}

.textArea {
  min-height: 80px;
  resize: vertical;
}

/* ========== BUTTONS ========== */
.btn {
  padding: 16px 32px;
  border-radius: 16px;
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.3s ease;
  border: none;
  position: relative;
  overflow: hidden;
  font-family: inherit;
  min-width: 140px;
}

.btn::before {
  content: "";
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.2),
    transparent
  );
  transition: left 0.5s ease;
}

.btn:hover:not(:disabled)::before {
  left: 100%;
}

.btn.primary {
  background: linear-gradient(135deg, #5d44f3, #b523d2, #241a4a);
  color: #ffffff;
  box-shadow:
    0 10px 40px rgba(124, 58, 237, 0.5),
    inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

.btn.primary:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow:
    0 15px 40px rgba(168, 85, 247, 0.5),
    inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

.btn.secondary {
  background: rgba(30, 20, 60, 0.6);
  color: var(--text);
  border: 1px solid rgba(168, 85, 247, 0.4);
  backdrop-filter: blur(10px);
}

.btn.secondary:hover:not(:disabled) {
  background: rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.3);
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn:active:not(:disabled) {
  transform: translateY(0);
}

/* ========== STICKY NAVIGATION ========== */
.sticky {
  /* position: fixed; */
  /* bottom: 0; */
  /* left: 50%; */
  /* transform: translateX(-50%); */
  /* width: calc(100% - 32px); */
  padding: 16px;
  /* z-index: 10; */
  margin-top: -80px;
}

.stickyInner {
  max-width: 525px;
  margin: 0 auto;
  display: flex;
  gap: 16px;
  align-items: center;
  justify-content: space-between;
}

.sticky .btn {
  min-width: 140px;
}

/* ========== MANUAL MODE SPECIFIC ========== */
.manualSectionTitle {
  font-size: 18px;
  font-weight: 700;
  color: #ffffff;
  margin: 24px 0 16px;
  letter-spacing: 0.02em;
}

.manualRow {
  margin-bottom: 14px;
}

.manualSelect {
  width: 100%;
  padding: 12px 14px;
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 10px;
  color: var(--text);
  font-size: 14px;
  transition: all 0.3s ease;
  backdrop-filter: blur(10px);
  cursor: pointer;
  font-family: inherit;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L6 6L11 1' stroke='%23ffffff' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 14px center;
  padding-right: 36px;
}

.manualSelect:focus {
  outline: none;
  border-color: var(--accent);
  background-color: rgba(255, 255, 255, 0.08);
  box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.1);
}

.manualPills {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.manualPill {
  padding: 14px 24px;
  background: rgba(30, 20, 60, 0.5);
  backdrop-filter: blur(10px);
  border: 2px solid rgba(168, 85, 247, 0.4);
  border-radius: 16px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 16px;
  font-weight: 600;
  color: var(--text);
  user-select: none;
  position: relative;
  overflow: hidden;
}

.manualPill::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

.manualPill:hover {
  border-color: rgba(168, 85, 247, 0.4);
  transform: translateY(-2px);
}

.manualPill.selected {
  border-color: rgba(168, 85, 247, 0.8);
  background: rgba(168, 85, 247, 0.15);
  box-shadow: 0 0 30px rgba(168, 85, 247, 0.5);
}

.manualPill.selected::before {
  opacity: 0.1;
}

.manualCheckboxRow {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px;
  background: rgba(255, 255, 255, 0.03);
  border-radius: 10px;
  margin-bottom: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 13px;
  color: var(--text);
}

.manualCheckboxRow:hover {
  background: rgba(255, 255, 255, 0.05);
}

.manualCheckboxRow input[type="checkbox"] {
  width: 18px;
  height: 18px;
  border-radius: 5px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  background: transparent;
  cursor: pointer;
  appearance: none;
  flex-shrink: 0;
  transition: all 0.3s ease;
  position: relative;
}

.manualCheckboxRow input[type="checkbox"]:checked {
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  border-color: transparent;
}

.manualCheckboxRow input[type="checkbox"]:checked::after {
  content: "‚úì";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 11px;
  font-weight: 700;
}

.manualSummary {
  background: rgba(30, 20, 50, 0.8);
  border: 1px solid var(--card-border);
  border-radius: 12px;
  padding: 14px;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.5;
  white-space: pre-wrap;
}

.manualButtons {
  display: flex;
  gap: 8px;
  margin-top: 16px;
  flex-wrap: wrap;
}

.manualBtn {
  flex: 1;
  min-width: 120px;
  padding: 12px 20px;
  border-radius: 999px;
  font-size: 13px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.3s ease;
  border: none;
  font-family: inherit;
}

.manualBtn.primary {
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  color: #ffffff;
  box-shadow: 0 10px 30px rgba(168, 85, 247, 0.4);
}

.manualBtn.primary:hover {
  transform: translateY(-2px);
  box-shadow: 0 15px 40px rgba(168, 85, 247, 0.5);
}

.manualBtn.secondary {
  background: rgba(255, 255, 255, 0.05);
  color: var(--text);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.manualBtn.secondary:hover {
  background: rgba(255, 255, 255, 0.1);
}

.manualTag {
  display: inline-block;
  padding: 3px 8px;
  background: rgba(168, 85, 247, 0.2);
  border-radius: 999px;
  font-size: 10px;
  font-weight: 700;
  color: var(--accent2);
  margin-left: 6px;
}

/* ========== UTILITY CLASSES ========== */
.hidden {
  display: none !important;
}

/* ========== RESPONSIVE ========== */
@media (max-width: 480px) {
  body {
      background-position: top center;
  }
  .wrap{
    padding-right: 15px;
    padding-left: 15px;
  }
  #guidedMode{
    width: 100%;
  }
  .mainContainer {
    padding: 16px 8px;
  }
  .entryCard {
    border: 3px solid rgba(168, 85, 247, 0.3);
    border-radius: 24px;
    width: 95%;
    box-shadow: 6px 20px 68px rgba(0, 0, 0, 1);
  }
  .entryCard:hover {
     background: rgba(20, 15, 40, .3);
    backdrop-filter: blur(20px);
    border: 3px solid rgba(168, 85, 247, 0.3);
    border-radius: 24px;
    width: 90%;
    box-shadow: 6px 20px 68px rgba(0, 0, 0, 1);
    
  }
  .card {
    padding: 32px 20px;
  }
  .entryBtn{
    background: rgba(20, 15, 40, 0.52);
  }
  .phoneFrame {
    display: none;
    border-radius: 28px;
    padding: 10px;
  }

  .phoneInner {
    display: none;
    border-radius: 22px;
    padding: 12px;
  }

  h1 {
    font-size: 20px;
  }

  .entryTitle {
    font-size: 30px;
  }

  .pillGrid {
    grid-template-columns: 1fr;
  }

  .manualButtons {
    flex-direction: column;
  }

  .manualBtn {
    width: 100%;
  }

  .sticky {
    max-width: calc(100%);
    width: calc(100%);
  }
}

@media (min-width: 769px) and (max-width: 1024px) {
  .brand {
    font-size: 56px;
  }

  .entryTitle {
    font-size: 48px;
  }

  .wrap,
  .manualWrap {
    padding: 32px 24px 120px;
  }
}

@media (min-width: 769px) {
  .mainContainer {
    max-width: 600px;
  }

  .phoneFrame {
    display: none;
    margin-top: 20px;
  }
}
/* Layout tweaks for this portal page on Fourthwall */

/* Keep the footer hidden on this page (already above, but safe here too) */
.page__footer {
  display: none !important;
}

/* Let the portal control spacing, but give it some breathing room
   under the site header and above the bottom of the screen */
.page__main {
  display: block !important;
  padding-top: 40px !important;   /* distance from header ‚Äì adjust up/down */
  padding-bottom: 60px !important;/* space before bottom edge */
  margin-top: 0 !important;
  min-height: auto !important;
}

/* Vertically center the portal between header and bottom */
.page__main {
  min-height: calc(100vh - 100px) !important; /* subtract header height */
  display: flex !important;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding: 0 !important;
  margin: 0 !important;
}

    </style>
</head>
<body>
<div class="portalShell">
<!-- ========== MODE 1: ENTRY CHOOSER ========== -->
<div id="entryMode" class="entryWrap">
  <div class="entryKicker">DJ MOY ‚Ä¢ MIXING & MASTERING</div>
  <h1 class="entryTitle">Get your track mixed & mastered.</h1>

  <div class="entryCard">
    <div class="entryCardHeader">
      <div class="entryCardHeaderTitle">Choose how you want to start</div>
      <div class="entryCardHeaderText">
        Answer a few questions and I‚Äôll recommend the right service, or jump straight into a detailed manual setup.
      </div>
    </div>

    <div class="entryBtnGroup">
      <button id="btnEntryGuided" class="entryBtn entryBtnPrimary">
        <span class="entryBtnLabelMain">Help me decide</span>
        <span class="entryBtnLabelSub">Tell me about your song and I‚Äôll recommend the right service.</span>
        <span class="tag">Recommended</span>
      </button>

      <button id="btnEntryManual" class="entryBtn">
        <span class="entryBtnLabelMain">Manual setup</span>
        <span class="entryBtnLabelSub">Choose services and options yourself.</span>
      </button>
    </div>
  </div>
</div>

<!-- ========== MODE 2: GUIDED PORTAL ========== -->
<div id="guidedMode" class="hidden">
  <div class="wrap">
    <div class="kicker">DJ MOY ‚Ä¢ MIXING & MASTERING PORTAL</div>
    <h1>Mixing & Mastering</h1>
    <p class="sub">Tell me what you have and what you want ‚Äî I‚Äôll build the right package.</p>
    <div id="songCounter" style="margin-top:4px;color:var(--muted2);font-size:12px;"></div>

    <div class="stepsBar" id="stepsBar"></div>
    <div class="stepLabel" id="stepLabel"></div>

    <!-- STEP 1: TRACK TYPE -->
    <section class="card step" id="stepTrack">
      <div class="cardTitle">
        <h2>What best describes your track?</h2>
        <div class="hint"><span id="trackCount">0</span>/1</div>
      </div>
      <div class="pillGrid" id="trackGrid">
        <div class="pillCard" data-track="finished_song">
          <div>
            <span class="label">üéß One finished song file</span>
            <span class="meta">A single stereo file (no separate stems)</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>

        <div class="pillCard" data-track="vocals_beat">
          <div>
            <span class="label">üé§ Separate vocals + instrumental</span>
            <span class="meta">One or more vocal files plus a separate beat / instrumental</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>

        <div class="pillCard" data-track="stems">
          <div>
            <span class="label">üì¶ Stems ‚Äì multiple files for different parts</span>
            <span class="meta">Drums, bass, guitars, vocals, FX, etc. as separate files</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>

        <div class="pillCard" data-track="raw_recording">
          <div>
            <span class="label">üéô Just a raw recording</span>
            <span class="meta">Voice, guitar, podcast, or similar</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>

        <div class="pillCard" data-track="track_unsure">
          <div>
            <span class="label">ü§∑ I‚Äôm not sure</span>
            <span class="meta">I‚Äôll help you decide later</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
      </div>
    </section>

    <!-- STEP 2: GOAL -->
    <section class="card step hidden" id="stepGoal">
      <div class="cardTitle">
        <h2>What do you want me to do?</h2>
        <div class="hint"><span id="goalCount">0</span>/1</div>
      </div>
      <div class="pillGrid" id="goalGrid">
        <div class="pillCard" data-goal="release_ready">
          <div>
            <span class="label">üöÄ Make it sound finished / release-ready</span>
            <span class="meta">Mix + Master</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
        <div class="pillCard" data-goal="improve_mix">
          <div>
            <span class="label">üéö Improve the mix / balance</span>
            <span class="meta">Mix only</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
        <div class="pillCard" data-goal="master_only">
          <div>
            <span class="label">üéß It‚Äôs mixed ‚Äî I just need it polished</span>
            <span class="meta">Master only</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
        <div class="pillCard" data-goal="vocals">
          <div>
            <span class="label">üåü Make my vocals sound professional</span>
            <span class="meta">Mix + Vocal Upgrade if needed</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
        <div class="pillCard" data-goal="problems">
          <div>
            <span class="label">üßº Fix problems in the audio</span>
            <span class="meta">Noise / harsh / muddy</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
        <div class="pillCard" data-goal="goal_unsure">
          <div>
            <span class="label">ü§ù I‚Äôm not sure ‚Äî recommend for me</span>
            <span class="meta">I‚Äôll pick the safest path</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
      </div>
    </section>

    <!-- STEP 3: ISSUES -->
    <section class="card step hidden" id="stepIssues">
      <div class="cardTitle">
        <h2>Any issues you‚Äôve noticed? <span style="font-weight:400;color:var(--muted2);">(optional)</span></h2>
        <div class="hint"><span id="issuesCount">0</span></div>
      </div>
      <div class="pillGrid" id="issuesGrid">
        <div class="pillCard" data-issue="noise">
          <div>
            <span class="label">‚ú® Noise / hiss / hum</span>
            <span class="meta">Room noise, fan noise, etc.</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
        <div class="pillCard" data-issue="vocals_tone">
          <div>
            <span class="label">üé§ Vocals lack clarity / presence</span>
            <span class="meta">Sound dull, thin, or buried</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
        <div class="pillCard" data-issue="harsh_muddy">
          <div>
            <span class="label">üßº Harsh or muddy overall</span>
            <span class="meta">Too sharp, boomy, or cloudy</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
        <div class="pillCard" data-issue="vocals_balance">
          <div>
            <span class="label">üéö Beat too loud vs vocals</span>
            <span class="meta">Vocals don‚Äôt sit right</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
        <div class="pillCard" data-issue="none">
          <div>
            <span class="label">‚úÖ No specific issues</span>
            <span class="meta">Sounds pretty good already</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
      </div>
    </section>

    <!-- STEP 4: STEMS INFO -->
    <section class="card step hidden" id="stepStemsInfo">
      <div class="cardTitle">
        <h2>Before you send stems</h2>
        <div class="hint">Quick heads-up</div>
      </div>
      <div class="miniNote">
        <strong>What are stems?</strong><br/>
        Separate audio files for different parts ‚Äî for example: drums, bass, guitars, lead vocal, backing vocals, FX, etc.
      </div>
      <div class="miniNote">
        <strong>How to save money:</strong><br/>
        You can bounce groups as one stem (like ‚Äúall guitars‚Äù or ‚Äúall backing vocals‚Äù). Fewer stems = cheaper; more stems = more individual control.
      </div>
      <div class="miniNote">
        Just organize your files how you want them treated ‚Äî I‚Äôll mix based on what you send.
      </div>
    </section>

    <!-- STEP 5: STEMS COUNT -->
    <section class="card step hidden" id="stepStemsCount">
      <div class="cardTitle">
        <h2>How many stems will you send?</h2>
        <div class="hint"><span id="tierCount">0</span>/1</div>
      </div>
      <div class="pillGrid" id="tierGrid">
        <div class="pillCard" data-tier="1-4">
          <div>
            <span class="label">1‚Äì4 stems</span>
            <span class="meta">Small / simple session</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
        <div class="pillCard" data-tier="5-8">
          <div>
            <span class="label">5‚Äì8 stems</span>
            <span class="meta">Typical song</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
        <div class="pillCard" data-tier="9-16">
          <div>
            <span class="label">9‚Äì16 stems</span>
            <span class="meta">Detailed arrangement</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
        <div class="pillCard" data-tier="17-24">
          <div>
            <span class="label">17‚Äì24 stems</span>
            <span class="meta">Full production</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
        <div class="pillCard" data-tier="25+">
          <div>
            <span class="label">25+ stems (custom quote)</span>
            <span class="meta">Large / complex project ‚Äì I‚Äôll follow up on pricing</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
      </div>
      <div class="miniNote">
        Count each audio file you‚Äôll send as one stem. If you bounce ‚Äúall guitars‚Äù together, that counts as <strong>one</strong> stem.<br/><br/>
        <strong>Note:</strong> Standard pricing covers up to 24 stems. If you select <strong>25+ stems</strong>, I‚Äôll treat it as a custom quote.
      </div>
    </section>

    <!-- STEP 6: ADD-ONS -->
    <section class="card step hidden" id="stepAddons">
      <div class="cardTitle">
        <h2>Add-ons (per song)</h2>
        <div class="hint">Optional</div>
      </div>
      <div class="pillGrid" id="addonsGrid">
        <div class="pillCard" data-addon="noise">
          <div>
            <span class="label">‚ú® Noise cleanup</span>
            <span class="meta">Reduce hiss, hum, and room noise across the song</span>
            <span class="autoNote" id="autoNoteNoise"></span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
        <div class="pillCard" data-addon="vocal">
          <div>
            <span class="label">üé§ Vocal Upgrade</span>
            <span class="meta">Full vocal chain to studio-ready (tone, clarity, tuning, FX)</span>
            <span class="autoNote" id="autoNoteVocal"></span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
        <div class="pillCard" data-addon="priority">
          <div>
            <span class="label">‚ö° Priority delivery</span>
            <span class="meta">Move your project toward the front of the queue</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
        <div class="pillCard" data-addon="revision">
          <div>
            <span class="label">üîÅ Extra revision</span>
            <span class="meta">Add one extra revision round</span>
          </div>
          <span class="dot" aria-hidden="true"></span>
        </div>
      </div>
      <div class="miniNote">
        You‚Äôll see everything summarized before checkout. Prices are per song, not per stem.
      </div>
    </section>

    <!-- STEP 7: RECOMMENDATION -->
    <section class="card step hidden" id="stepRec">
      <div class="cardTitle">
        <h2>Recommendation</h2>
        <div class="hint">Auto-built from your answers</div>
      </div>
      <div class="miniNote" id="recHeadline"></div>
      <div class="miniNote">
        <strong>What I‚Äôm recommending</strong>
        <ul class="recList" id="recList"></ul>
      </div>
      <div class="miniNote warn hidden" id="recWarning"></div>
    </section>

    <!-- STEP 8: SONG DETAILS -->
    <section class="card step hidden" id="stepDetails">
      <div class="cardTitle">
        <h2>Song details</h2>
        <div class="hint">Artist & track info</div>
      </div>

      <div class="fieldGroup">
        <div class="fieldLabel">Artist name *</div>
        <input id="detailArtist" class="textInput" type="text" placeholder="e.g., DJ Moy" />
      </div>

      <div class="fieldGroup">
        <div class="fieldLabel">Song title *</div>
        <input id="detailSong" class="textInput" type="text" placeholder="e.g., Wildcard" />
      </div>

      <div class="fieldGroup">
        <div class="fieldLabel">Genre (optional)</div>
        <input id="detailGenre" class="textInput" type="text" placeholder="e.g., Dubstep, Trap, Pop" />
      </div>

      <div class="fieldGroup">
        <div class="fieldLabel">Tempo (BPM) (optional)</div>
        <input id="detailBpm" class="textInput" type="text" placeholder="e.g., 140" />
      </div>

      <div class="fieldGroup">
        <div class="fieldLabel">Key (optional)</div>
        <input id="detailKey" class="textInput" type="text" placeholder="e.g., F minor" />
      </div>

      <div class="fieldGroup">
        <div class="fieldLabel">Notes / references (optional)</div>
        <textarea id="detailNotes" class="textArea" placeholder="Anything I should know, or links to reference tracks."></textarea>
      </div>

      <div class="miniNote">
        Artist name and song title are required so I can keep your project organized. Everything else just helps me dial in the sound faster.
      </div>
    </section>

    <!-- STEP 9: REVIEW -->
    <section class="card step hidden" id="stepReview">
      <div class="cardTitle">
        <h2>Review</h2>
        <div class="hint">Almost there</div>
      </div>
      <div class="miniNote">
        <strong>Your selections (current song)</strong>
        <div id="reviewText" style="margin-top:8px;color:var(--muted);font-size:12.5px;line-height:1.45;"></div>
      </div>
      <div class="miniNote" id="projectCountNote" style="margin-top:10px;">
        This project currently includes 1 song.
      </div>
      <button class="btn secondary" id="btnAddSongGuided" style="margin-top:10px;width:100%;">Add another song</button>
      <div class="miniNote" style="margin-top:10px;">
        <strong>Next:</strong> You‚Äôll check out on the store, then an upload page opens in a new tab.
        Paste your <strong>Order #</strong>, <strong>checkout email</strong>, and a <strong>share link</strong> to your files (Google Drive / Dropbox / WeTransfer ZIP with all stems).
      </div>
    </section>
  </div>

  <!-- Guided sticky nav -->
  <div class="sticky" id="guidedSticky">
    <div class="stickyInner">
      <button class="btn secondary" id="btnBack">Back</button>
      <button class="btn primary" id="btnNext">Next</button>
    </div>
  </div>
</div>

<!-- ========== MODE 3: MANUAL / ADVANCED CONFIG ========== -->
<div id="manualMode" class="hidden">
  <div class="manualWrap">
    <div class="manualHeader">
      <div>
        <div class="kicker">DJ MOY ‚Ä¢ MANUAL SETUP</div>
        <h2>Manual setup</h2>
      </div>
      <div class="manualTag">Advanced</div>
    </div>

    <div id="manualSongNumber" style="margin:4px 0 8px; font-size:13px; font-weight:700; color:var(--muted2);">
      Song 1 of 1
    </div>

    <div class="modeBackLink" id="manualBackToEntry">‚Üê Back to mode selection</div>

    <p class="sub" style="margin-top:8px;">
      Choose your services and options directly. This mode is ideal if you‚Äôre already comfortable
      with terms like stems, mixing, and mastering.
    </p>

    <!-- Manual song details -->
    <section class="card">
      <div class="manualSectionTitle">Song details</div>
      <div class="manualRow">
        <div class="fieldGroup">
          <div class="fieldLabel">Artist name *</div>
          <input id="manualArtist" class="textInput" type="text" placeholder="e.g., DJ Moy" />
        </div>
        <div class="fieldGroup">
          <div class="fieldLabel">Song title *</div>
          <input id="manualSong" class="textInput" type="text" placeholder="e.g., Wildcard" />
        </div>
        <div class="fieldGroup">
          <div class="fieldLabel">Genre (optional)</div>
          <input id="manualGenre" class="textInput" type="text" placeholder="e.g., Dubstep, Trap, Pop" />
        </div>
        <div class="fieldGroup">
          <div class="fieldLabel">Tempo (BPM) (optional)</div>
          <input id="manualBpm" class="textInput" type="text" placeholder="e.g., 140" />
        </div>
        <div class="fieldGroup">
          <div class="fieldLabel">Key (optional)</div>
          <input id="manualKey" class="textInput" type="text" placeholder="e.g., F minor" />
        </div>
        <div class="fieldGroup">
          <div class="fieldLabel">Notes / references (optional)</div>
          <textarea id="manualNotes" class="textArea" placeholder="Anything I should know, or links to reference tracks."></textarea>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="manualSectionTitle">1. Services</div>
      <div class="manualRow">
        <div class="manualPills" id="manualServices">
          <div class="manualPill" data-service="mix">üéö Mix</div>
          <div class="manualPill" data-service="master">üéß Master</div>
          <div class="manualPill" data-service="mixmaster">üöÄ Mix + Master</div>
        </div>
      </div>

      <div class="manualSectionTitle">2. What files will you send?</div>
      <div class="manualRow">
        <select id="manualFileType" class="manualSelect">
          <option value="">Select an option‚Ä¶</option>
          <option value="finished_song">One finished song file (stereo mix)</option>
          <option value="vocals_beat">Separate vocals + instrumental</option>
          <option value="stems">Stems ‚Äì multiple files for different parts</option>
          <option value="raw_recording">Raw recording (voice, guitar, podcast, etc.)</option>
        </select>
      </div>

      <div class="manualSectionTitle" id="manualStemTitle" style="display:none;">3. Stem count (for mixing)</div>
      <div class="manualRow" id="manualStemRow" style="display:none;">
        <select id="manualStemTier" class="manualSelect">
          <option value="">Select stem range‚Ä¶</option>
          <option value="1-4">1‚Äì4 stems (small / simple)</option>
          <option value="5-8">5‚Äì8 stems (typical song)</option>
          <option value="9-16">9‚Äì16 stems (detailed arrangement)</option>
          <option value="17-24">17‚Äì24 stems (full production)</option>
          <option value="25+">25+ stems (custom quote)</option>
        </select>
        <div class="miniNote" style="margin-top:8px;">
          Each audio file you send counts as one stem. Grouped stems like ‚Äúall guitars‚Äù
          count as <strong>one</strong> stem. Standard pricing covers up to 24 stems; 25+ is a custom quote.
        </div>
      </div>

      <div class="manualSectionTitle">4. Add-ons (per song)</div>
      <div class="manualRow">
        <label class="manualCheckboxRow">
          <input type="checkbox" id="manualNoise" />
          <span>‚ú® Noise cleanup ‚Äì reduce hiss, hum, and room noise across the song</span>
        </label>
        <label class="manualCheckboxRow">
          <input type="checkbox" id="manualVocal" />
          <span>üé§ Vocal Upgrade ‚Äì full vocal chain to studio-ready (tone, tuning, FX)</span>
        </label>
        <label class="manualCheckboxRow">
          <input type="checkbox" id="manualPriority" />
          <span>‚ö° Priority delivery ‚Äì move your project toward the front of the queue</span>
        </label>
        <label class="manualCheckboxRow">
          <input type="checkbox" id="manualRevision" />
          <span>üîÅ Extra revision ‚Äì add one extra revision round</span>
        </label>
      </div>

      <div class="manualSectionTitle">Summary</div>
      <div class="manualSummary" id="manualSummary">
        Choose services and options to see a summary here.
      </div>

      <div class="miniNote" id="manualProjectCountNote" style="margin-top:10px;">
        This project currently includes 1 song.
      </div>

      <div class="manualSectionTitle" style="margin-top:10px;">Songs in this project</div>
      <div class="manualSummary" id="manualSongList">
        Song 1: (current song ‚Äì not added yet)
      </div>

      <div class="manualButtons">
        <button class="manualBtn secondary" id="manualAddSong">Add another song</button>
        <button class="manualBtn secondary" id="manualReset">Reset</button>
        <button class="manualBtn primary" id="manualCheckout">Upload (Prototype)</button>
      </div>
    </section>
  </div>
</div>
</div>
// end of portalshell

<script>
  const $ = id => document.getElementById(id);
  const qsa = (sel, root=document) => Array.from(root.querySelectorAll(sel));

  // ===== TALLY CONFIG =====
  const TALLY_FORM_ID = "1A4Ajp";
  const TALLY_BASE_URL = `https://tally.so/r/${TALLY_FORM_ID}`;

// ===== FOURTHWALL CONFIG =====
const FW_STOREFRONT_TOKEN = "ptkn_f9e58f99-75f2-42c3-bc33-6bdcb04c50e1";
const FW_API_BASE = "https://storefront-api.fourthwall.com/v1";
const FW_CHECKOUT_DOMAIN = "dj-moy-shop.fourthwall.com";

// Map our logical services -> Fourthwall variant IDs
const FW_VARIANTS = {
  // Core services
  masterOnly: "33435bba-ca97-4c76-98de-86430ba6286e",

  mixOnly_1_4:  "268a008e-6fb3-4cd2-b3dd-76c1dfcd6074",
  mixOnly_5_8:  "57bf5428-c8e3-4f9a-bd36-a7331efd6c6c",
  mixOnly_9_16: "ed140375-2b43-4246-93d2-362bc4971dda",
  mixOnly_17_24:"8afc82bd-2831-47db-bd18-26d0b41729bf",

  mixMaster_1_4:  "ee466308-52ea-48ff-885b-9ad1c8dc6005",
  mixMaster_5_8:  "32b246c4-5d2d-4976-b0ff-5b7039dc1f28",
  mixMaster_9_16: "1c242db5-8ae2-4129-bf93-51b61b460a83",
  mixMaster_17_24:"0d5adf90-9d3b-4d6c-b28b-7d1a928f1cda",

  // Add-ons
  vocalUpgrade:   "47d8cbf3-f1d0-493d-8686-8779b4de6e23",
  noiseCleanup:   "fcff8cf8-381e-4e87-8463-91ae6728da49",
  extraRevision:  "64772271-f04b-4586-85b0-da9b8b42b9d0",
  priorityDelivery:"5e092988-6c51-425d-b1ee-a0f81148bd64",

  // Custom project / quote
  customProject:  "a80fdabc-6ecb-4078-9d14-8c163ce4347c"
};

  // Shared metadata (current song)
  const metaState = {
    artistName: "",
    songTitle: "",
    genre: "",
    bpm: "",
    key: "",
    extraNotes: ""
  };

  // Guided mode project songs
  const guidedSongs = []; // { artistName, songTitle, summary }
  let guidedSongIndex = 1;

  // Manual mode project songs
  const manualSongs = [];

  function buildServicesLabel(mix, master){
    if (mix && master) return "Mix + Master";
    if (mix) return "Mix";
    if (master) return "Master";
    return "";
  }

  function buildAddonsLabelFromGuided(){
    const a = [];
    if (guidedState.addons.noiseReduction) a.push("Noise cleanup");
    if (guidedState.addons.vocalUpgrade) a.push("Vocal Upgrade");
    if (guidedState.addons.priority) a.push("Priority delivery");
    if (guidedState.addons.extraRevision) a.push("Extra revision");
    return a;
  }

  function buildAddonsLabelFromManual(){
    const a = [];
    if (manualState.addons.noise) a.push("Noise cleanup");
    if (manualState.addons.vocal) a.push("Vocal Upgrade");
    if (manualState.addons.priority) a.push("Priority delivery");
    if (manualState.addons.revision) a.push("Extra revision");
    return a;
  }
function getManualAddonsSummary(){
  return buildAddonsLabelFromManual();
}

  function updateSongCounter(){
    const el = $("songCounter");
    if (!el) return;
    el.textContent = `Song ${guidedSongIndex}`;
  }

  function updateManualSongNumber(){
    const total = manualSongs.length + 1;
    const current = total;
    $("manualSongNumber").textContent = `Song ${current} of ${total}`;
  }

  /* -------- MODE SWITCH -------- */
  function showMode(mode){
    $("entryMode").classList.toggle("hidden", mode !== "entry");
    $("guidedMode").classList.toggle("hidden", mode !== "guided");
    $("manualMode").classList.toggle("hidden", mode !== "manual");
    window.scrollTo({top:0});
  }

  $("btnEntryGuided").addEventListener("click", ()=> showMode("guided"));
  $("btnEntryManual").addEventListener("click", ()=> showMode("manual"));
  $("manualBackToEntry").addEventListener("click", ()=> showMode("entry"));

  /* ========= GUIDED MODE ========= */

  const guidedState = {
    trackType: null,
    goal: null,
    issues: new Set(),
    stems: { tier: null },
    addons: {
      noiseReduction:false,
      vocalUpgrade:false,
      priority:false,
      extraRevision:false
    },
    unsure:{ track:false, goal:false },
    addonsInitialized:false
  };

  const guidedRec = {
    mixing:false,
    mastering:false,
    vocalUpgrade:false,
    noiseReduction:false,
    stemTier:null,
    headline:"",
    bullets:[],
    warning:null
  };

  const addonAutoReasons = { noise:null, vocal:null };
  let stepIndex = 0;

  function steps(){
    return [
      {id:"stepTrack", label:"Track"},
      {id:"stepGoal", label:"Goal"},
      {id:"stepIssues", label:"Issues"},
      {id:"stepStemsInfo", label:"Stems Info"},
      {id:"stepStemsCount", label:"Stems"},
      {id:"stepAddons", label:"Add-ons"},
      {id:"stepRec", label:"Recommendation"},
      {id:"stepDetails", label:"Details"},
      {id:"stepReview", label:"Review"}
    ];
  }

  function renderStepper(){
    const s = steps();
    $("stepsBar").innerHTML = "";
    s.forEach((_, idx)=>{
      const d = document.createElement("div");
      d.className = "stepDot" + (idx <= stepIndex ? " on" : "");
      $("stepsBar").appendChild(d);
    });
    $("stepLabel").textContent = `${stepIndex+1}/${s.length} ‚Ä¢ ${s[stepIndex].label}`;
  }

  function shouldNeedStemsFlow(){
    const t = guidedState.trackType;
    const g = guidedState.goal;
    const hasMulti = (t === "stems" || t === "vocals_beat");
    const wantsMix = (
      g === "release_ready" ||
      g === "improve_mix" ||
      g === "vocals" ||
      g === "problems" ||
      g === "goal_unsure"
    );
    return hasMulti && wantsMix;
  }

  function canGoNext(){
    const id = steps()[stepIndex].id;
    if (id === "stepTrack") return !!guidedState.trackType;
    if (id === "stepGoal") return !!guidedState.goal;
    if (id === "stepIssues") return true;
    if (id === "stepStemsInfo") return true;
    if (id === "stepStemsCount"){
      if (!shouldNeedStemsFlow()) return true;
      return !!guidedState.stems.tier;
    }
    if (id === "stepAddons") return true;
    if (id === "stepRec") return true;
    if (id === "stepDetails"){
      return metaState.artistName.trim() !== "" && metaState.songTitle.trim() !== "";
    }
    if (id === "stepReview") return true;
    return true;
  }

  function updateNextState(){
    $("btnNext").disabled = !canGoNext();
  }

  function showStep(idx){
    const s = steps();
    stepIndex = Math.max(0, Math.min(idx, s.length-1));
    qsa(".step").forEach(el=>el.classList.add("hidden"));
    $(s[stepIndex].id).classList.remove("hidden");
    $("btnBack").disabled = false;
    $("btnNext").textContent = (s[stepIndex].id === "stepReview") ? "Upload" : "Next";
    renderStepper();

    const id = s[stepIndex].id;
    if (id === "stepAddons"){
      ensureAddonsInitialized();
      syncAddonsUI();
    }
    if (id === "stepRec") buildRecommendation();
    if (id === "stepReview") renderReview();

    updateNextState();
    window.scrollTo({top:0, behavior:"smooth"});
  }

  function bindSingle(gridId, key, countId, unsureKey, attr){
    const items = qsa(`#${gridId} .pillCard`);
    items.forEach(el=>{
      el.addEventListener("click", ()=>{
        items.forEach(x=>x.classList.remove("selected"));
        el.classList.add("selected");
        const v = el.getAttribute(attr);
        guidedState[key] = v;
        if (countId) $(countId).textContent = "1";
        if (unsureKey){
          guidedState.unsure[unsureKey] = (v === `${unsureKey}_unsure`);
        }
        updateNextState();
      });
    });
  }

  function bindIssues(){
    const items = qsa("#issuesGrid .pillCard");
    items.forEach(el=>{
      el.addEventListener("click", ()=>{
        const v = el.getAttribute("data-issue");
        if (v === "none"){
          guidedState.issues.clear();
          items.forEach(x=>x.classList.remove("selected"));
          el.classList.add("selected");
          guidedState.issues.add("none");
          $("issuesCount").textContent = "0";
          updateNextState();
          return;
        }
        if (guidedState.issues.has("none")){
          guidedState.issues.delete("none");
          const noneEl = items.find(x=>x.getAttribute("data-issue")==="none");
          if (noneEl) noneEl.classList.remove("selected");
        }
        const isOn = el.classList.toggle("selected");
        if (isOn) guidedState.issues.add(v); else guidedState.issues.delete(v);
        $("issuesCount").textContent = String(guidedState.issues.size);
        updateNextState();
      });
    });
  }

  function bindStemsCount(){
    const items = qsa("#tierGrid .pillCard");
    items.forEach(el=>{
      el.addEventListener("click", ()=>{
        items.forEach(x=>x.classList.remove("selected"));
        el.classList.add("selected");
        guidedState.stems.tier = el.getAttribute("data-tier");
        $("tierCount").textContent = "1";
        updateNextState();
      });
    });
  }

  function inferNoiseReason(base){
    const issues = guidedState.issues;
    const t = guidedState.trackType;
    const g = guidedState.goal;
    if (issues.has("noise"))
      return "you mentioned noise / hiss / hum in your audio.";
    if (t === "raw_recording")
      return "you‚Äôre working from a raw recording where room noise is common.";
    if (g === "problems")
      return "you said your audio has problems that need fixing.";
    return "your earlier answers suggested noise cleanup would help.";
  }

  function inferVocalReason(base){
    const issues = guidedState.issues;
    const g = guidedState.goal;
    const t = guidedState.trackType;
    if (g === "vocals")
      return "you said you want your vocals to sound professional.";
    if (issues.has("vocals_tone") || issues.has("vocals_balance"))
      return "you mentioned issues with vocal clarity or vocal/beat balance.";
    if (t === "vocals_beat")
      return "you‚Äôre working with separate vocals and a beat.";
    return "your earlier answers suggested a vocal upgrade would help.";
  }

  function ensureAddonsInitialized(){
    if (guidedState.addonsInitialized) return;
    const base = computeRecBase();
    if (base.suggestNoise){
      guidedState.addons.noiseReduction = true;
      addonAutoReasons.noise = inferNoiseReason(base);
    }
    if (base.suggestVocalUpgrade){
      guidedState.addons.vocalUpgrade = true;
      addonAutoReasons.vocal = inferVocalReason(base);
    }
    guidedState.addonsInitialized = true;
  }

  function bindAddons(){
    const items = qsa("#addonsGrid .pillCard");
    items.forEach(el=>{
      el.addEventListener("click", ()=>{
        const key = el.getAttribute("data-addon");
        const isSelected = el.classList.toggle("selected");
        if (key === "noise") guidedState.addons.noiseReduction = isSelected;
        if (key === "vocal") guidedState.addons.vocalUpgrade = isSelected;
        if (key === "priority") guidedState.addons.priority = isSelected;
        if (key === "revision") guidedState.addons.extraRevision = isSelected;
        syncAddonsUI();
      });
    });
  }

  function syncAddonsUI(){
    const items = qsa("#addonsGrid .pillCard");
    items.forEach(el=>{
      const key = el.getAttribute("data-addon");
      let on = false;
      if (key === "noise") on = guidedState.addons.noiseReduction;
      if (key === "vocal") on = guidedState.addons.vocalUpgrade;
      if (key === "priority") on = guidedState.addons.priority;
      if (key === "revision") on = guidedState.addons.extraRevision;
      el.classList.toggle("selected", !!on);
    });

    const noiseNote = $("autoNoteNoise");
    const vocalNote = $("autoNoteVocal");

    if (noiseNote){
      if (addonAutoReasons.noise && guidedState.addons.noiseReduction){
        noiseNote.textContent = `Auto-selected because ${addonAutoReasons.noise}`;
      } else {
        noiseNote.textContent = "";
      }
    }
    if (vocalNote){
      if (addonAutoReasons.vocal && guidedState.addons.vocalUpgrade){
        vocalNote.textContent = `Auto-selected because ${addonAutoReasons.vocal}`;
      } else {
        vocalNote.textContent = "";
      }
    }
  }

  function computeRecBase(){
    const base = {
      mixing:false,
      mastering:false,
      suggestVocalUpgrade:false,
      suggestNoise:false,
      warning:null,
      notes:[]
    };

    const t = guidedState.trackType;
    const g = guidedState.goal;
    const issues = guidedState.issues;

    const vocalsIssues = issues.has("vocals_tone") || issues.has("vocals_balance");
    const noiseIssues = issues.has("noise");
    const harshIssues = issues.has("harsh_muddy");

    if (g === "release_ready"){ base.mixing=true; base.mastering=true; }
    if (g === "improve_mix"){ base.mixing=true; }
    if (g === "master_only"){ base.mastering=true; }
    if (g === "vocals"){ base.mixing=true; base.suggestVocalUpgrade=true; }
    if (g === "problems"){ base.mixing=true; base.suggestNoise=true; }
    if (g === "goal_unsure"){ base.mixing=true; base.mastering=true; }

    if (t === "finished_song"){
      if (base.mixing || base.suggestVocalUpgrade){
        base.warning = "With one mixed file, true mixing or deep vocal work is limited. For full control, stems or at least separate vocal + beat files are best.";
      }
      base.mixing=false;
      base.suggestVocalUpgrade=false;
      base.mastering=true;
    }

    if (t === "vocals_beat"){
      if (g === "master_only"){
        base.mixing=false;
        base.mastering=true;
      } else {
        base.mixing=true;
      }
      if (g === "vocals" || vocalsIssues){
        base.suggestVocalUpgrade=true;
      }
    }

    if (t === "stems"){
      if (!base.mixing && !base.mastering){
        base.mixing=true;
      }
    }

    if (t === "raw_recording"){
      base.suggestNoise=true;
      if (!base.mixing && !base.mastering){
        base.mastering=true;
      }
    }

    if (t === "track_unsure"){
      base.mastering=true;
      base.notes.push("You selected ‚ÄúI‚Äôm not sure‚Äù for your files. I‚Äôm defaulting to a safe path; on the upload page you can clarify what you have.");
    }

    if (noiseIssues) base.suggestNoise=true;
    if (vocalsIssues || g === "vocals") base.suggestVocalUpgrade=true;
    if (harshIssues && !base.mixing && t !== "finished_song"){
      base.mixing=true;
    }

    return base;
  }

  function prettyStemTier(t){
    const map = {
      "1-4":"1‚Äì4 stems",
      "5-8":"5‚Äì8 stems",
      "9-16":"9‚Äì16 stems",
      "17-24":"17‚Äì24 stems",
      "25+":"25+ stems (custom quote)"
    };
    return map[t] || t || "";
  }

  function buildRecommendation(){
    const base = computeRecBase();

    guidedRec.mixing = base.mixing;
    guidedRec.mastering = base.mastering;
    guidedRec.vocalUpgrade = guidedState.addons.vocalUpgrade;
    guidedRec.noiseReduction = guidedState.addons.noiseReduction;
    guidedRec.stemTier = guidedState.stems.tier;
    guidedRec.warning = base.warning;
    guidedRec.bullets = [];
    guidedRec.headline = "";

    const serviceLabel =
      (guidedRec.mixing && guidedRec.mastering) ? "üöÄ Release-Ready Package" :
      (guidedRec.mixing) ? "üéö Mixing" :
      "üéß Mastering";

    const translation =
      (guidedRec.mixing && guidedRec.mastering) ? "(Mix + Master)" :
      (guidedRec.mixing) ? "(Mix)" :
      "(Master)";

    let unsureTag = "";
    if (guidedState.unsure.track || guidedState.unsure.goal){
      unsureTag = `<br/><span style="color:var(--muted2);font-size:12px;">You chose ‚ÄúI‚Äôm not sure‚Äù ‚Äî this is the safest path based on your answers.</span>`;
    }

    guidedRec.headline = `<strong>Best fit:</strong> ${serviceLabel} <span style="color:var(--muted2);font-weight:800;">${translation}</span>${unsureTag}`;
    $("recHeadline").innerHTML = guidedRec.headline;

    const bullets = [];

    if (guidedRec.mixing && guidedRec.mastering){
      bullets.push("We‚Äôll build a clean, balanced mix, then finalize loudness and polish for release.");
    } else if (guidedRec.mixing){
      bullets.push("We‚Äôll build a clean, balanced mix that translates on speakers and headphones.");
    } else {
      bullets.push("We‚Äôll optimize loudness and tonal balance and check translation (stereo and mono).");
    }

    if (guidedState.trackType === "stems" && guidedRec.stemTier){
      if (guidedRec.stemTier === "25+"){
        bullets.push("Mixing from stems ‚Äî over 24 stems (custom quote level).");
      } else {
        bullets.push(`Mixing from stems (${prettyStemTier(guidedRec.stemTier)}).`);
      }
    }

    if (guidedState.trackType === "vocals_beat"){
      bullets.push("Working from separate vocal file(s) plus instrumental/beat.");
    }

    if (guidedRec.vocalUpgrade){
      bullets.push("üé§ Vocal Upgrade added: full vocal chain from raw to studio-ready (tone, clarity, tuning, FX).");
    } else if (computeRecBase().suggestVocalUpgrade){
      bullets.push("Tip: Vocal Upgrade would give you a full vocal chain for more professional vocals.");
    }

    if (guidedRec.noiseReduction){
      bullets.push("‚ú® Noise cleanup added: project-level hiss / hum / room noise reduction.");
    } else if (computeRecBase().suggestNoise){
      bullets.push("Tip: Noise cleanup is recommended if you notice hiss, hum, or room noise.");
    }

    if (guidedState.addons.priority){
      bullets.push("‚ö° Priority delivery selected (your project moves up in the queue).");
    }
    if (guidedState.addons.extraRevision){
      bullets.push("üîÅ Extra revision selected for more flexibility.");
    }

    if (guidedState.goal === "release_ready" || guidedState.goal === "goal_unsure"){
      bullets.push("If you‚Äôre unsure: ‚ÄúMixing‚Äù makes everything sit right together ‚Äî ‚ÄúMastering‚Äù makes it release-ready.");
    }

    if (guidedState.stems.tier === "25+"){
      bullets.push("Because this is a large session (25+ stems), I‚Äôll follow up with a custom quote after you submit your files.");
    }

    guidedRec.bullets = bullets;

    const ul = $("recList");
    ul.innerHTML = "";
    guidedRec.bullets.forEach(t=>{
      const li = document.createElement("li");
      li.textContent = t;
      ul.appendChild(li);
    });

    const w = $("recWarning");
    if (guidedRec.warning){
      w.textContent = guidedRec.warning;
      w.classList.remove("hidden");
    } else {
      w.classList.add("hidden");
    }

    updateNextState();
  }

  function prettyGoal(g){
    const map = {
      release_ready:"Make it sound finished / release-ready",
      improve_mix:"Improve the mix / balance",
      master_only:"Already mixed ‚Äî polish it",
      vocals:"Make my vocals sound professional",
      problems:"Fix problems in the audio",
      goal_unsure:"I‚Äôm not sure (recommend for me)"
    };
    return map[g] || g || "‚Äî";
  }

  function prettyTrack(t){
    const map = {
      finished_song:"One finished song file",
      vocals_beat:"Separate vocals + instrumental",
      stems:"Stems ‚Äì multiple files for different parts",
      raw_recording:"Raw recording",
      track_unsure:"Not sure"
    };
    return map[t] || t || "‚Äî";
  }

  function prettyIssue(i){
    const map = {
      noise:"Noise / hiss / hum",
      vocals_tone:"Vocals lack clarity / presence",
      harsh_muddy:"Harsh / muddy",
      vocals_balance:"Beat too loud vs vocals",
      none:"No specific issues"
    };
    return map[i] || i;
  }

  function getGuidedAddonsSummary(){
    const addons = [];
    if (guidedState.addons.noiseReduction) addons.push("Noise cleanup");
    if (guidedState.addons.vocalUpgrade) addons.push("Vocal Upgrade");
    if (guidedState.addons.priority) addons.push("Priority delivery");
    if (guidedState.addons.extraRevision) addons.push("Extra revision");
    return addons;
  }

  function buildGuidedSongDescriptor(){
    const parts = [];
    const { artistName, songTitle, genre, bpm, key, extraNotes } = metaState;

    const trackLabels = {
      finished_song: "Finished song file",
      vocals_beat: "Vocal + beat file",
      stems: "Separated stems",
      raw_recording: "Raw recording / demo",
      track_unsure: "Track (unsure what files yet)"
    };

    const trackType = guidedState.trackType;
    const trackLabel = trackLabels[trackType] || "Track";

    const hasMix = guidedRec.mixing;
    const hasMaster = guidedRec.mastering;
    const stemTierLabel = prettyStemTier(guidedRec.stemTier);

    // Services line
    if (hasMix && hasMaster) parts.push("Mix + Master");
    else if (hasMix) parts.push("Mix only");
    else if (hasMaster) parts.push("Master only");

    // File type line
    parts.push(trackLabel);

    // Stem tier text if we‚Äôre actually mixing
    if (hasMix && stemTierLabel){
      parts.push(`Stems: ${stemTierLabel}`);
    }

    // Issues (guidedState.issues is a Set)
    const issues = [];
    if (guidedState.issues.has("noise")) issues.push("Noise / hiss / hum");
    if (guidedState.issues.has("vocals_tone")) issues.push("Vocals lack clarity / presence");
    if (guidedState.issues.has("harsh_muddy")) issues.push("Harsh / muddy overall");
    if (guidedState.issues.has("vocals_balance")) issues.push("Beat too loud vs vocals");
    if (issues.length){
      parts.push(`Issues to fix: ${issues.join(", ")}`);
    }

    // Add-ons summary
    const addons = getGuidedAddonsSummary();
    if (addons.length){
      parts.push(`Add-ons: ${addons.join(", ")}`);
    }

    // Extra metadata
    if (genre) parts.push(`Genre: ${genre}`);
    if (bpm) parts.push(`BPM: ${bpm}`);
    if (key) parts.push(`Key: ${key}`);
    if (extraNotes) parts.push(`Notes: ${extraNotes}`);

    // ----- Cart metadata for this song -----
    let serviceType = null;
    if (hasMix && hasMaster) serviceType = "mixmaster";
    else if (hasMix) serviceType = "mix";
    else if (hasMaster) serviceType = "master";

    const stemTier = guidedRec.stemTier || null;

    const cartInfo = {
      serviceType,        // "mix" | "master" | "mixmaster" | null
      stemTier,           // "1-4" | "5-8" | "9-16" | "17-24" | "25+" | null
      addons: {
        noise: !!guidedState.addons.noiseReduction,
        vocalUpgrade: !!guidedState.addons.vocalUpgrade,
        priority: !!guidedState.addons.priority,
        extraRevision: !!guidedState.addons.extraRevision
      }
    };

    return {
      artistName: artistName || "Unknown Artist",
      songTitle: songTitle || "Untitled Song",
      summary: parts.join(" ‚Ä¢ "),
      cartInfo
    };
  }



  function renderReview(){
    const desc = buildGuidedSongDescriptor();
    $("reviewText").textContent = desc.summary;

    const totalSongs = guidedSongs.length + 1;
    $("projectCountNote").textContent = totalSongs === 1
      ? "This project currently includes 1 song."
      : `This project currently includes ${totalSongs} songs.`;
  }

  function updateMetaFromDetails(){
    const a = $("detailArtist");
    const s = $("detailSong");
    const g = $("detailGenre");
    const b = $("detailBpm");
    const k = $("detailKey");
    const n = $("detailNotes");

    if (a) metaState.artistName = a.value || "";
    if (s) metaState.songTitle = s.value || "";
    if (g) metaState.genre = g.value || "";
    if (b) metaState.bpm = b.value || "";
    if (k) metaState.key = k.value || "";
    if (n) metaState.extraNotes = n.value || "";

    updateNextState();
  }

  function bindDetailsInputs(){
    ["detailArtist","detailSong","detailGenre","detailBpm","detailKey","detailNotes"]
      .forEach(id=>{
        const el = $(id);
        if (!el) return;
        el.addEventListener("input", updateMetaFromDetails);
      });
  }

  function resetGuidedForNewSong(keepArtist){
    ["trackGrid","goalGrid","issuesGrid","tierGrid","addonsGrid"].forEach(gridId=>{
      qsa(`#${gridId} .pillCard`).forEach(x=>x.classList.remove("selected"));
    });
    $("trackCount").textContent = "0";
    $("goalCount").textContent = "0";
    $("issuesCount").textContent = "0";
    $("tierCount").textContent = "0";
    if ($("autoNoteNoise")) $("autoNoteNoise").textContent = "";
    if ($("autoNoteVocal")) $("autoNoteVocal").textContent = "";

    guidedState.trackType = null;
    guidedState.goal = null;
    guidedState.issues = new Set();
    guidedState.stems = { tier:null };
    guidedState.addons = {
      noiseReduction:false,
      vocalUpgrade:false,
      priority:false,
      extraRevision:false
    };
    guidedState.unsure = { track:false, goal:false };
    guidedState.addonsInitialized = false;
    addonAutoReasons.noise = null;
    addonAutoReasons.vocal = null;

    guidedRec.mixing = false;
    guidedRec.mastering = false;
    guidedRec.vocalUpgrade = false;
    guidedRec.noiseReduction = false;
    guidedRec.stemTier = null;
    guidedRec.headline = "";
    guidedRec.bullets = [];
    guidedRec.warning = null;

    const preservedArtist = keepArtist ? (metaState.artistName || "") : "";
    metaState.artistName = preservedArtist;
    metaState.songTitle = "";
    metaState.genre = "";
    metaState.bpm = "";
    metaState.key = "";
    metaState.extraNotes = "";

    if ($("detailArtist")) $("detailArtist").value = preservedArtist;
    ["detailSong","detailGenre","detailBpm","detailKey","detailNotes"].forEach(id=>{
      const el = $(id);
      if (el) el.value = "";
    });

    guidedSongIndex += 1;
    updateSongCounter();
    showStep(0);
  }

  function buildProjectSongsTextFromGuided(){
    const all = guidedSongs.slice();
    all.push(buildGuidedSongDescriptor());

    const lines = [];
    all.forEach((song, idx)=>{
      lines.push(`Song ${idx+1}:`);
      lines.push(`- Title: ${song.songTitle}`);
      lines.push(`- Artist: ${song.artistName}`);
      lines.push(`- Details: ${song.summary}`);
      lines.push("");
    });
    return lines.join("\n");
  }

  function buildGuidedTallyURL(){
    const projectSongsText = buildProjectSongsTextFromGuided();
    const allCount = guidedSongs.length + 1;
    const isMulti = allCount > 1;

    const servicesLabel = isMulti
      ? "Multiple songs ‚Äì see projectSongs"
      : buildServicesLabel(guidedRec.mixing, guidedRec.mastering);

    const addonsArr = buildAddonsLabelFromGuided();
    const addonsLabel = isMulti
      ? "Multiple songs ‚Äì see projectSongs"
      : (Array.isArray(addonsArr) && addonsArr.length ? addonsArr.join(", ") : "");


    const stemCountLabel = isMulti
      ? "Multiple songs ‚Äì see projectSongs"
      : (
          guidedState.trackType === "stems" && guidedState.stems.tier
            ? prettyStemTier(guidedState.stems.tier)
            : ""
        );

    const topArtist = metaState.artistName || "Unknown artist";
    const topSong = isMulti ? "(multiple songs)" : (metaState.songTitle || "Untitled");

    const params = new URLSearchParams({
      artistName: topArtist,
      songTitle: topSong,
      genre: metaState.genre,
      bpm: metaState.bpm,
      key: metaState.key,
      services: servicesLabel,
      addons: addonsLabel,
      stemCount: stemCountLabel,
      extraNotes: metaState.extraNotes,
      projectSongs: projectSongsText
    });

    return `${TALLY_BASE_URL}?${params.toString()}`;
  }

  function guidedInit(){
    bindSingle("trackGrid","trackType","trackCount","track","data-track");
    bindSingle("goalGrid","goal","goalCount","goal","data-goal");
    bindIssues();
    bindStemsCount();
    bindAddons();
    bindDetailsInputs();

    $("btnBack").addEventListener("click", ()=>{
      const s = steps();
      const id = s[stepIndex].id;
      if (stepIndex === 0){
        showMode("entry");
        return;
      }
      if (id === "stepAddons" && !shouldNeedStemsFlow()){
        showStep(stepIndex - 3);
      } else {
        showStep(stepIndex - 1);
      }
    });

    $("btnNext").addEventListener("click", ()=>{
      const s = steps();
      const id = s[stepIndex].id;

      if (!canGoNext()) return;

      if (id === "stepIssues"){
        if (shouldNeedStemsFlow()){
          showStep(stepIndex + 1);
        } else {
          showStep(stepIndex + 3);
        }
        return;
      }

     if (id === "stepReview"){
     // Final guided step: build cart + open Tally + go to checkout
     handlePortalCheckout("guided");
     return;
   }


      showStep(stepIndex + 1);
    });

    $("btnAddSongGuided").addEventListener("click", ()=>{
      if (!metaState.artistName || !metaState.songTitle){
        alert("Please fill in Artist name and Song title before adding another song.");
        return;
      }
      const desc = buildGuidedSongDescriptor();
      guidedSongs.push(desc);
      resetGuidedForNewSong(true);
    });

    updateSongCounter();
    showStep(0);
  }

  /* ========= MANUAL MODE ========= */

  const manualState = {
    services: new Set(),
    fileType: "",
    stemTier: "",
    addons: {
      noise:false,
      vocal:false,
      priority:false,
      revision:false
    }
  };

  function updateManualStemVisibility(){
    const ft = manualState.fileType;
    const needsStems = (ft === "stems" || ft === "vocals_beat");
    $("manualStemTitle").style.display = needsStems ? "block" : "none";
    $("manualStemRow").style.display = needsStems ? "block" : "none";
  }

  function updateManualProjectCountNote(){
    const total = manualSongs.length + 1;
    const el = $("manualProjectCountNote");
    if (!el) return;
    el.textContent = total === 1
      ? "This project currently includes 1 song."
      : `This project currently includes ${total} songs.`;
  }

  function updateManualSongList(){
    const container = $("manualSongList");
    if (!container) return;

    const all = manualSongs.slice();
    all.push(buildManualSongDescriptor());

    if (!all.length){
      container.textContent = "No songs added yet.";
      return;
    }

    const lines = all.map((song, idx)=> `${idx+1}. ${song.artistName} ‚Äì ${song.songTitle}`);
    container.textContent = "Songs in this project:\n" + lines.join("\n");
  }

  function updateManualSummary(){
    const parts = [];

    if (metaState.artistName || metaState.songTitle){
      parts.push(
        "Project: " +
        (metaState.artistName || "Unknown artist") +
        " ‚Äì " +
        (metaState.songTitle || "Untitled")
      );
    }

    if (manualState.services.size){
      const list = [];
      const hasMix = manualState.services.has("mix");
      const hasMaster = manualState.services.has("master");
      const hasMixmaster = manualState.services.has("mixmaster");

      if (hasMixmaster || (hasMix && hasMaster)){
        list.push("Mix + Master");
      } else {
        if (hasMix) list.push("Mix");
        if (hasMaster) list.push("Master");
      }
      parts.push("Services: " + list.join(", "));
    } else {
      parts.push("Services: (none selected yet)");
    }

    if (manualState.fileType){
      parts.push("Files: " + prettyTrack(manualState.fileType));
    } else {
      parts.push("Files: (not set)");
    }

    if (manualState.stemTier && (manualState.fileType==="stems" || manualState.fileType==="vocals_beat")){
      parts.push("Stem range: " + prettyStemTier(manualState.stemTier));
    }

    const addonList = buildAddonsLabelFromManual();
    if (addonList.length){
      parts.push("Add-ons: " + addonList.join(", "));
    } else {
      parts.push("Add-ons: (none)");
    }

    if (manualState.stemTier === "25+"){
      parts.push("Note: 25+ stems will require a custom quote after you upload your files.");
    }

    $("manualSummary").textContent = parts.join(" ‚Ä¢ ");
    updateManualProjectCountNote();
    updateManualSongList();
    updateManualSongNumber();
  }

  function updateMetaFromManualDetails(){
    const a = $("manualArtist");
    const s = $("manualSong");
    const g = $("manualGenre");
    const b = $("manualBpm");
    const k = $("manualKey");
    const n = $("manualNotes");

    if (a) metaState.artistName = a.value || "";
    if (s) metaState.songTitle = s.value || "";
    if (g) metaState.genre = g.value || "";
    if (b) metaState.bpm = b.value || "";
    if (k) metaState.key = k.value || "";
    if (n) metaState.extraNotes = n.value || "";

    updateManualSummary();
  }

  function buildManualSongDescriptor(){
  const { artistName, songTitle, genre, bpm, key, extraNotes } = metaState;
  const parts = [];

  const hasMix = manualState.services.has("mix");
  const hasMaster = manualState.services.has("master");
  const services = [];
  if (hasMix) services.push("Mix");
  if (hasMaster) services.push("Master");

  if (services.length === 2) parts.push("Mix + Master");
  else if (services.length === 1) parts.push(services[0]);

  const prettyFileType = {
    finished_song: "Finished song file",
    vocals_beat: "Vocal + beat file",
    stems: "Separated stems",
    raw_recording: "Raw recording / demo"
  };

  const fileTypeLabel = prettyFileType[manualState.fileType];
  if (fileTypeLabel) parts.push(fileTypeLabel);

  if (manualState.fileType === "stems" && manualState.stemTier){
    parts.push(`Stems: ${manualState.stemTier} stems`);
  }

  const addonsList = getManualAddonsSummary();
  if (addonsList.length){
    parts.push(`Add-ons: ${addonsList.join(", ")}`);
  }

  if (genre) parts.push(`Genre: ${genre}`);
  if (bpm) parts.push(`BPM: ${bpm}`);
  if (key) parts.push(`Key: ${key}`);
  if (extraNotes) parts.push(`Notes: ${extraNotes}`);

  // ----- Cart metadata for this song -----
  let serviceType = null;
  if (hasMix && hasMaster) serviceType = "mixmaster";
  else if (hasMix) serviceType = "mix";
  else if (hasMaster) serviceType = "master";

  let stemTier = null;
  if (manualState.fileType === "stems" && manualState.stemTier){
    stemTier = manualState.stemTier; // "1-4", "5-8", "9-16", "17-24", "25+"
  }

  const cartInfo = {
    serviceType,
    stemTier,
    addons: {
      noise: !!manualState.addons.noise,
      vocalUpgrade: !!manualState.addons.vocal,
      priority: !!manualState.addons.priority,
      extraRevision: !!manualState.addons.revision
    }
  };

  return {
    artistName: artistName || "Unknown Artist",
    songTitle: songTitle || "Untitled Song",
    summary: parts.join(" ‚Ä¢ "),
    cartInfo
  };
}


  function buildManualProjectSongsText(){
    const all = manualSongs.slice();
    all.push(buildManualSongDescriptor());

    const lines = [];
    all.forEach((song, idx)=>{
      lines.push(`Song ${idx+1}:`);
      lines.push(`- Title: ${song.songTitle}`);
      lines.push(`- Artist: ${song.artistName}`);
      lines.push(`- Details: ${song.summary}`);
      lines.push("");
    });
    return lines.join("\n");
  }

  function buildManualTallyURL(){
    const all = manualSongs.slice();
    all.push(buildManualSongDescriptor());
    const total = all.length;
    const isMulti = total > 1;

    const servicesLabel = (()=>{
      if (isMulti) return "Multiple songs ‚Äì see projectSongs";
      const hasMix = manualState.services.has("mix");
      const hasMaster = manualState.services.has("master");
      const hasMixmaster = manualState.services.has("mixmaster");
      const mixing = hasMix || hasMixmaster;
      const mastering = hasMaster || hasMixmaster;
      return buildServicesLabel(mixing, mastering);
    })();

    const addonsArr = buildAddonsLabelFromManual();
    const addonsLabel = isMulti
      ? "Multiple songs ‚Äì see projectSongs"
      : (Array.isArray(addonsArr) && addonsArr.length ? addonsArr.join(", ") : "");


    const stemCountLabel = isMulti
      ? "Multiple songs ‚Äì see projectSongs"
      : (
          (manualState.fileType === "stems" || manualState.fileType === "vocals_beat") && manualState.stemTier
            ? prettyStemTier(manualState.stemTier)
            : ""
        );

    const topArtist = metaState.artistName || "Unknown artist";
    const topSong = isMulti ? "(multiple songs)" : (metaState.songTitle || "Untitled");
    const projectSongsText = buildManualProjectSongsText();

    const params = new URLSearchParams({
      artistName: topArtist,
      songTitle: topSong,
      genre: metaState.genre,
      bpm: metaState.bpm,
      key: metaState.key,
      services: servicesLabel,
      addons: addonsLabel,
      stemCount: stemCountLabel,
      extraNotes: metaState.extraNotes,
      projectSongs: projectSongsText
    });

    return `${TALLY_BASE_URL}?${params.toString()}`;
  }

  function resetManualState(keepArtist){
    manualState.services.clear();
    manualState.fileType = "";
    manualState.stemTier = "";
    manualState.addons = {noise:false,vocal:false,priority:false,revision:false};

    qsa("#manualServices .manualPill").forEach(x=>x.classList.remove("selected"));
    $("manualFileType").value = "";
    $("manualStemTier").value = "";
    $("manualNoise").checked = false;
    $("manualVocal").checked = false;
    $("manualPriority").checked = false;
    $("manualRevision").checked = false;

    const preservedArtist = keepArtist ? (metaState.artistName || "") : "";
    metaState.artistName = preservedArtist;
    metaState.songTitle = "";
    metaState.genre = "";
    metaState.bpm = "";
    metaState.key = "";
    metaState.extraNotes = "";

    if ($("manualArtist")) $("manualArtist").value = preservedArtist;
    ["manualSong","manualGenre","manualBpm","manualKey","manualNotes"].forEach(id=>{
      const el = $(id);
      if (el) el.value = "";
    });

    updateManualStemVisibility();
    updateManualSummary();
  }

  function guidedInitOnce(){
    guidedInit();
  }

  function manualInit(){
    ["manualArtist","manualSong","manualGenre","manualBpm","manualKey","manualNotes"]
      .forEach(id=>{
        const el = $(id);
        if (!el) return;
        el.addEventListener("input", updateMetaFromManualDetails);
      });

    qsa("#manualServices .manualPill").forEach(el=>{
      el.addEventListener("click", ()=>{
        const key = el.getAttribute("data-service");
        const mixmasterPill = qsa("#manualServices .manualPill").find(x=>x.getAttribute("data-service")==="mixmaster");

        if (key === "mixmaster"){
          manualState.services.clear();
          manualState.services.add("mix");
          manualState.services.add("master");
          qsa("#manualServices .manualPill").forEach(x=>x.classList.remove("selected"));
          el.classList.add("selected");
        } else {
          if (mixmasterPill) mixmasterPill.classList.remove("selected");

          const isOn = !el.classList.contains("selected");
          el.classList.toggle("selected", isOn);
          if (isOn) manualState.services.add(key);
          else manualState.services.delete(key);
        }
        updateManualSummary();
      });
    });

    $("manualFileType").addEventListener("change", e=>{
      manualState.fileType = e.target.value;
      updateManualStemVisibility();
      updateManualSummary();
    });

    $("manualStemTier").addEventListener("change", e=>{
      manualState.stemTier = e.target.value;
      updateManualSummary();
    });

    $("manualNoise").addEventListener("change", e=>{
      manualState.addons.noise = e.target.checked;
      updateManualSummary();
    });
    $("manualVocal").addEventListener("change", e=>{
      manualState.addons.vocal = e.target.checked;
      updateManualSummary();
    });
    $("manualPriority").addEventListener("change", e=>{
      manualState.addons.priority = e.target.checked;
      updateManualSummary();
    });
    $("manualRevision").addEventListener("change", e=>{
      manualState.addons.revision = e.target.checked;
      updateManualSummary();
    });

    $("manualReset").addEventListener("click", ()=>{
      manualSongs.length = 0;
      resetManualState(false);
      updateManualSongNumber();
    });

    $("manualAddSong").addEventListener("click", ()=>{
      if (!metaState.artistName || !metaState.songTitle){
        alert("Please fill in Artist name and Song title before adding another song.");
        return;
      }
      const desc = buildManualSongDescriptor();
      manualSongs.push(desc);
      resetManualState(true);
      updateManualSongNumber();
    });

    $("manualCheckout").addEventListener("click", ()=>{
  if (!metaState.artistName || !metaState.songTitle){
    alert("Please fill in Artist name and Song title before continuing.");
    return;
  }
  // Manual mode: build cart + open Tally + go to checkout
  handlePortalCheckout("manual");
});


    updateManualStemVisibility();
    updateManualSummary();
    updateManualSongNumber();
  }
// ===== FOURTHWALL CART HELPERS =====

function getAllSongsForCart(mode){
  if (mode === "guided"){
    const songs = guidedSongs.slice();
    songs.push(buildGuidedSongDescriptor());
    return songs;
  }
  if (mode === "manual"){
    const songs = manualSongs.slice();
    songs.push(buildManualSongDescriptor());
    return songs;
  }
  return [];
}

function mapServiceToVariantId(serviceType, stemTier){
  if (serviceType === "master"){
    return FW_VARIANTS.masterOnly;
  }

  if (!stemTier){
    return null;
  }

  const tier = stemTier; // "1-4", "5-8", "9-16", "17-24", "25+"

  if (tier === "25+"){
    // We‚Äôll handle this as a custom project instead of a normal SKU
    return null;
  }

  if (serviceType === "mix"){
    if (tier === "1-4")  return FW_VARIANTS.mixOnly_1_4;
    if (tier === "5-8")  return FW_VARIANTS.mixOnly_5_8;
    if (tier === "9-16") return FW_VARIANTS.mixOnly_9_16;
    if (tier === "17-24")return FW_VARIANTS.mixOnly_17_24;
  }

  if (serviceType === "mixmaster"){
    if (tier === "1-4")  return FW_VARIANTS.mixMaster_1_4;
    if (tier === "5-8")  return FW_VARIANTS.mixMaster_5_8;
    if (tier === "9-16") return FW_VARIANTS.mixMaster_9_16;
    if (tier === "17-24")return FW_VARIANTS.mixMaster_17_24;
  }

  return null;
}

function addCartItem(store, key, variantId, quantity){
  if (!store[key]){
    store[key] = { variantId, quantity: 0 };
  }
  store[key].quantity += quantity;
}

function buildCartLineItemsFromSongs(songs){
  const itemsByKey = {};
  let hasPriority = false;
  let needsCustomQuote = false;

  for (const song of songs){
    const info = song.cartInfo;
    if (!info || !info.serviceType) continue;

    // Custom project trigger (25+ stems)
    if (info.stemTier === "25+"){
      needsCustomQuote = true;
      continue;
    }

    const baseVariantId = mapServiceToVariantId(info.serviceType, info.stemTier);
    if (baseVariantId){
      const baseKey = `${info.serviceType}_${info.stemTier || "noTier"}`;
      addCartItem(itemsByKey, baseKey, baseVariantId, 1);
    }

    // Per-track add-ons
    if (info.addons.noise){
      addCartItem(itemsByKey, "noiseCleanup", FW_VARIANTS.noiseCleanup, 1);
    }
    if (info.addons.vocalUpgrade){
      addCartItem(itemsByKey, "vocalUpgrade", FW_VARIANTS.vocalUpgrade, 1);
    }
    if (info.addons.extraRevision){
      addCartItem(itemsByKey, "extraRevision", FW_VARIANTS.extraRevision, 1);
    }

    // Priority is per-project (one per portal session)
    if (info.addons.priority){
      hasPriority = true;
    }
  }

  if (hasPriority){
    addCartItem(itemsByKey, "priorityDelivery", FW_VARIANTS.priorityDelivery, 1);
  }

  if (needsCustomQuote){
    addCartItem(itemsByKey, "customProject", FW_VARIANTS.customProject, 1);
  }

  return Object.values(itemsByKey);
}

async function createFourthwallCart(lineItems){
  // Fourthwall Storefront API: POST /v1/carts
  // Auth is via storefront_token query param, not Authorization header
  const url =
    `${FW_API_BASE}/carts?storefront_token=${encodeURIComponent(FW_STOREFRONT_TOKEN)}&currency=USD`;

  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ items: lineItems })
  });

  let data;
  try {
    data = await response.json();
  } catch (e){
    console.error("Error parsing Fourthwall response:", e);
  }

  if (!response.ok){
    console.error("Fourthwall error response:", data);
    throw new Error(
      (data && (data.title || data.detail)) ||
      `Failed to create cart (status ${response.status})`
    );
  }

  console.log("Fourthwall cart created:", data);
  return data;
}

async function handlePortalCheckout(mode){
  // 1) Build the list of songs for this mode
  const songs = getAllSongsForCart(mode);
  if (!songs.length){
    alert("Please add at least one song before continuing.");
    return;
  }

  // 2) Build cart line items
  const lineItems = buildCartLineItemsFromSongs(songs);
  if (!lineItems.length){
    alert("Nothing to add to cart based on your selections. Please double-check your services.");
    return;
  }

  console.log("Fourthwall line items:", lineItems);

  // 3) Open Tally upload form in a new tab
  let tallyURL = mode === "guided" ? buildGuidedTallyURL() : buildManualTallyURL();

  // Guard: if a builder misbehaves, fall back to base form instead of a blank tab
  if (!tallyURL || typeof tallyURL !== "string"){
    console.error("Tally URL builder returned an invalid value:", tallyURL);
    tallyURL = TALLY_BASE_URL;
  }

 console.log("Opening Tally URL:", tallyURL);

  // Open Tally form in another tab
  const tallyTab = window.open("", "_blank");
  if (tallyTab && tallyURL){
    tallyTab.location.href = tallyURL;
  } else if (tallyURL){
    window.open(tallyURL, "_blank");
  }

  // Try to keep THIS tab in front (not guaranteed in every browser,
  // but often works when called from a user click handler)
  if (window.focus){
    window.focus();
  }

  // Optional but HIGHLY recommended: tell the user the flow
  alert(
    "Step 1: In this tab, you‚Äôll be sent to checkout to add your services to the cart.\n\n" +
    "Step 2: A new tab with the upload form has been opened. " +
    "After you finish checkout, switch to that tab to upload your files."
  );

  // 3.5) If we're running locally (file preview / localhost), skip the API cart step.
  const isLocalEnv =
    location.protocol === "file:" ||
    location.hostname === "localhost" ||
    location.hostname === "127.0.0.1";

  if (isLocalEnv){
    console.warn("Skipping Fourthwall cart creation in local preview.");
    alert(
      "Your upload form is open in a new tab.\n\n" +
      "Because this is a local preview, the store cart can't be created automatically. " +
      "On the real site, this step will add everything to your cart for you."
    );
    return;
  }

  // 4) Create cart and send user to the store cart page
  try {
    const cart = await createFourthwallCart(lineItems);

    if (!cart || !cart.id){
      console.error("Cart created but no id found:", cart);
      alert(
        "Cart creation succeeded but no checkout link was returned.\n\n" +
        "Please add the services manually in the store."
      );
      return;
    }

    // Keep using /cart since you said that URL worked for you
    const checkoutUrl =
  `https://${FW_CHECKOUT_DOMAIN}/checkout/?cartCurrency=USD&cartId=${encodeURIComponent(cart.id)}`;


    window.location.href = checkoutUrl;
  } catch (err){
    console.error("Error creating your Fourthwall cart:", err);
    alert(
      "There was a problem creating your cart automatically.\n\n" +
      "Your upload form is already open in a new tab ‚Äî " +
      "please add the services manually on the store."
    );
  }
}

// Final init ‚Äî leave this exactly as-is
guidedInitOnce();
manualInit();
showMode("entry");

</script>
</body>
</html>
